// The MiMCSponge contract is not written in Solidity. Instead, its bytecode is
// generated by circomlib/src/mimcsponge_gencontract.js.
//
// Most (if not all) Solidity tooling frameworks, like Etherlime or Truffle,
// do not integrate the solc binary and therefore take ages to compile
// contracts.
//
// This script does the following:
//
// 1. Build the MiMC contract bytecode and deploy it to the Ethereum node
//    specified by --rpcUrl.
// 2. Copy Solidity files from the semaphore submodule to sol/semaphore
// 2. Compile the Solidity files specified by --input using the solc binary
//    specified by --solc. All output files will be in the directory specified
//    by --out.
// 3. Link the MiMC contract address to hardcoded contract(s) (just
//    MerkleTreeLib for now)
// 4. Deploy the rest of the contracts, except for the RelayerReputation and RelayForwarder.
// 5. Check whether bytecode exists on-chain at the addresses of
//    RelayerReputation and RelayForwarder set in config.chain.contracts.
// 6. If so, attach to them. Otherwise, deploy them.


import { config } from 'ao-config'
import { ArgumentParser } from 'argparse'
import * as shell from 'shelljs'
import * as path from 'path'
import * as fs from 'fs'
import * as ethers from 'ethers'

const mimcGenContract = require('circomlib/src/mimcsponge_gencontract.js')
const MIMC_SEED = 'mimcsponge'

const buildMimcBytecode = () => {
    return mimcGenContract.createCode(MIMC_SEED, 220)
}

const execute = (cmd: string) => {
    const result = shell.exec(cmd, { silent: false })
    if (result.code !== 0) {
        throw 'Error executing ' + cmd
    }

    return result
}

const readFile = (abiDir: string, filename: string) => {
    return fs.readFileSync(path.join(abiDir, filename)).toString()
}

const compileAndDeploy = async (
    abiDir: string,
    solDir: string,
    solcBinaryPath: string = 'solc',
    rpcUrl: string = config.chain.url,
    deployKey: string = config.chain.keys.deploy,
    nftAddress?: string,
) => {

    const readAbiAndBin = (name: string) => {
        const abi = readFile(abiDir, name + '.abi')
        const bin = readFile(abiDir, name + '.bin')
        return { abi, bin }
    }

    // copy Semaphore files
    const semaphorePathPrefix = '../semaphore/semaphorejs/contracts/'
    const semaphoreTargetPath = path.join(solDir, 'semaphore')
    shell.mkdir('-p', semaphoreTargetPath)

    const semaphoreSolFiles = ['Semaphore.sol', 'MerkleTreeLib.sol', 'Ownable.sol']
    for (let file of semaphoreSolFiles) {
        shell.cp('-f', path.join(semaphorePathPrefix, file), semaphoreTargetPath)
    }

    shell.cp('-f', path.join(semaphorePathPrefix, '../build/verifier.sol'), semaphoreTargetPath)

    // copy BurnRegistry files
    const brPathPrefix = '../surrogeth/burnRegistry/contracts/'
    const brTargetPath = path.join(solDir, 'burnRegistry')
    shell.mkdir('-p', brTargetPath)
    const brSolFiles = ['RelayerForwarder.sol', 'RelayerReputation.sol', 'Ownable.sol', 'SafeMath.sol']
    for (let file of brSolFiles) {
        shell.cp('-f', path.join(brPathPrefix, file), brTargetPath)
    }

    // Build MiMC bytecode
    const mimcBin = buildMimcBytecode()

    // compile contracts
    shell.mkdir('-p', abiDir)
    const solcCmd = `${solcBinaryPath} -o ${abiDir} ${solDir}/*.sol ${solDir}/burnRegistry/*.sol --overwrite --optimize --abi --bin`
    const result = execute(solcCmd)

    // create provider and wallet
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
    const wallet = new ethers.Wallet(deployKey, provider)

    // deploy MiMC
    const mimcAbi = mimcGenContract.abi
    const mimcContractFactory = new ethers.ContractFactory(mimcAbi, mimcBin, wallet)

    const mimcContract = await mimcContractFactory.deploy()
    await mimcContract.deployed()
    console.log('MiMC deployed at', mimcContract.address)

    // link contracts to MiMC
    const filesToLink = ['semaphore/MerkleTreeLib.sol']
    for (let fileToLink of filesToLink) {
        const filePath = path.join(solDir, fileToLink)
        const linkCmd = `${solcCmd} --libraries ${filePath}:MiMC:${mimcContract.address}`
        execute(linkCmd)
    }

    // deploy or connect to the POAP contract
    const nftAbi = readFile(abiDir, 'Poap.abi')
    let nftContract

    if (nftAddress) {
        nftContract = new ethers.Contract(nftAddress, nftAbi, provider)
        console.log('Using existing NFT at', nftContract.address)
    } else {
        const nftBin = readFile(abiDir, 'Poap.bin')
        const nftContractFactory = new ethers.ContractFactory(nftAbi, nftBin, wallet)
        nftContract = await nftContractFactory.deploy()
        await nftContract.deployed()
        console.log('Deployed NFT at', nftContract.address)
    }

    // deploy Semaphore
    const semaphoreAB = readAbiAndBin('Semaphore')
    const semaphoreContractFactory = new ethers.ContractFactory(semaphoreAB.abi, semaphoreAB.bin, wallet)
    const semaphoreContract = await semaphoreContractFactory.deploy(config.chain.semaphoreTreeDepth, 0, 0)
    await semaphoreContract.deployed()

    console.log('Deployed Semaphore at', semaphoreContract.address)

    // deploy OneOfUs
    const oouAB = readAbiAndBin('OneOfUs')
    const oouContractFactory = new ethers.ContractFactory(oouAB.abi, oouAB.bin, wallet)
    const oouContract = await oouContractFactory.deploy(
        nftContract.address,
        semaphoreContract.address,
        config.chain.poapEventId,
    )
    await oouContract.deployed()
    console.log('Deployed OneOfUs at', oouContract.address)

    // set the owner of the Semaphore contract to the OneOfUs contract address
    const tx = await semaphoreContract.transferOwnership(oouContract.address)
    await tx.wait()
    console.log('Transferred ownership of the Semaphore contract')

    const rfAB = readAbiAndBin('RelayerForwarder')
    const rfContractFactory = new ethers.ContractFactory(rfAB.abi, rfAB.bin, wallet)
    let rfContract

    // check whether the RelayerForwarder contract exists
    const rfCode = await provider.getCode(config.chain.contracts.RelayerForwarder)
    if (rfCode.length > 2) {
        rfContract = rfContractFactory.attach(config.chain.contracts.RelayerForwarder)
        console.log('Using existing RelayerForwarder at', config.chain.contracts.RelayerForwarder)
    } else {
        rfContract = await rfContractFactory.deploy(
            config.chain.burnRegistry.burnNum,
            config.chain.burnRegistry.burnDenom,
        )
        await rfContract.deployed()
        console.log('Deployed RelayerForwarder at', rfContract.address)
    }

    const rrAB = readAbiAndBin('RelayerReputation')
    const rrContractFactory = new ethers.ContractFactory(rrAB.abi, rrAB.bin, wallet)
    let rrContract

    // check whether the RelayerReputation contract exists
    const rrCode = await provider.getCode(config.chain.contracts.RelayerReputation)
    if (rrCode.length > 2) {
        rrContract = rrContractFactory.attach(config.chain.contracts.RelayerReputation)
        console.log('Using existing RelayerReputation at', config.chain.contracts.RelayerReputation)
    } else {
        rrContract = await rrContractFactory.deploy(rfContract.address)
        await rrContract.deployed()
        console.log('Deployed RelayerReputation at', rrContract.address)

        const tx = await rfContract.setReputation(rrContract.address)
        await tx.wait()
    }
    
	return {
		MiMC: mimcContract,
		Semaphore: semaphoreContract,
		NFT: nftContract,
        OneOfUs: oouContract,
        RelayerForwarder: rfContract,
        RelayerReputation: rrContract,
	}
}

//function delay(milliseconds: number): Promise<void> {
    //return new Promise((resolve: Function) => setTimeout(resolve, milliseconds))
//}

if (require.main === module) {
    const parser = new ArgumentParser({
        description: 'Build and deploy contracts'
    })

    parser.addArgument(
        ['-s', '--solc'],
        {
            help: 'The path to the solc binary',
            required: false,
        }
    )

    parser.addArgument(
        ['-r', '--rpcUrl'],
        {
            help: 'The JSON-RPC URL of the Ethereum node',
            required: false,
        }
    )

    parser.addArgument(
        ['-o', '--out'],
        {
            help: 'The output directory for compiled files',
            required: true,
        }
    )

    parser.addArgument(
        ['-i', '--input'],
        {
            help: 'The input directory with .sol files',
            required: true,
        }
    )

    parser.addArgument(
        ['-k', '--privKey'],
        {
            help: 'The private key to use to deploy the contracts',
            required: false,
        }
    )

    parser.addArgument(
        ['-m', '--mainnet'],
        {
            help: 'Use the NFT contract address configured at config.chain.nftAddress',
            action: 'storeTrue',
        }
    )

    // parse command-line options
    const args = parser.parseArgs()

    const abiDir = path.resolve(args.out)
    const solDir = path.resolve(args.input)

    const deployKey = args.privKey ? args.privKey : config.chain.keys.deploy
    const solcBinaryPath = args.solc ? args.solc : 'solc'
    const rpcUrl = args.rpcUrl ? args.rpcUrl : config.chain.url
    const nftAddress = args.mainnet ? config.chain.nftAddress : null

    compileAndDeploy(abiDir, solDir, solcBinaryPath, rpcUrl, deployKey, nftAddress)

    //mkdir -p ../frontend/ts
    //cp -r compiled/abis ../frontend/ts/
    shell.mkdir('-p', '../frontend/ts/abi/')
    shell.cp('-R', path.join(abiDir, '*.abi'), '../frontend/ts/abi')
}

export {
    compileAndDeploy,
}
