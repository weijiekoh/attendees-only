// The MiMCSponge contract is not written in Solidity. Instead, its bytecode is
// generated by circomlib/src/mimcsponge_gencontract.js.
//
// Most (if not all) Solidity tooling frameworks, like Etherlime or Truffle,
// do not integrate the solc binary and therefore take ages to compile
// contracts.
//
// This script does the following:
//
// 1. Build the MiMC contract bytecode and deploy it to the Ethereum node
//    specified by --rpcUrl.
// 2. Copy Solidity files from the semaphore submodule to sol/semaphore
// 2. Compile the Solidity files specified by --input using the solc binary
//    specified by --solc. All output files will be in the directory specified
//    by --out.
// 3. Link the MiMC contract address to hardcoded contract(s) (just
//    MerkleTreeLib for now)
// 4. Deploy the rest of the contracts.


import { config } from 'ao-config'
import { ArgumentParser } from 'argparse'
import * as shell from 'shelljs'
import * as path from 'path'
import * as fs from 'fs'
import * as ethers from 'ethers'

const mimcGenContract = require('circomlib/src/mimcsponge_gencontract.js')
const MIMC_SEED = 'mimcsponge'

const buildMimcBytecode = () => {
    return mimcGenContract.createCode(MIMC_SEED, 220)
}

const execute = (cmd: string) => {
    return shell.exec(cmd, { silent: false })
}

const readFile = (abiDir: string, filename: string) => {
    return fs.readFileSync(path.join(abiDir, filename)).toString()
}

const compileAndDeploy = async (
    abiDir: string,
    solDir: string,
    solcBinaryPath: string = 'solc',
    rpcUrl: string = config.chain.url,
    deployKey: string = config.chain.keys.deploy,
    nftAddress?: string,
) => {

    // copy Semaphore files
    const semaphorePathPrefix = '../semaphore/semaphorejs/contracts/'
    const semaphoreTargetPath = path.join(solDir, 'semaphore')
    shell.mkdir('-p', semaphoreTargetPath)

    const semaphoreSolFiles = ['Semaphore.sol', 'MerkleTreeLib.sol', 'Ownable.sol']
    for (let file of semaphoreSolFiles) {
        shell.cp('-f', path.join(semaphorePathPrefix, file), semaphoreTargetPath)
    }

    shell.cp('-f', path.join(semaphorePathPrefix, '../build/verifier.sol'), semaphoreTargetPath)

    // Build MiMC bytecode
    const mimcBin = buildMimcBytecode()

    // compile contracts
    shell.mkdir('-p', abiDir)
    const solcCmd = `${solcBinaryPath} -o ${abiDir} ${solDir}/*.sol --overwrite --optimize --abi --bin`
    execute(solcCmd)

    // create provider and wallet
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl)
    const wallet = new ethers.Wallet(deployKey, provider)

    // deploy MiMC
    const mimcAbi = mimcGenContract.abi
    const mimcContractFactory = new ethers.ContractFactory(mimcAbi, mimcBin, wallet)

    const mimcContract = await mimcContractFactory.deploy()
    await mimcContract.deployed()
    console.log('MiMC deployed at', mimcContract.address)

    // link contracts to MiMC
    const filesToLink = ['semaphore/MerkleTreeLib.sol']
    for (let fileToLink of filesToLink) {
        const filePath = path.join(solDir, fileToLink)
        const linkCmd = `${solcCmd} --libraries ${filePath}:MiMC:${mimcContract.address}`
        execute(linkCmd)
    }

    // deploy or connect to the POAP contract
    const nftAbi = readFile(abiDir, 'Poap.abi')
    let nftContract

    if (nftAddress) {
        nftContract = new ethers.Contract(nftAddress, nftAbi, provider)
        console.log('Using existing NFT at', nftContract.address)
    } else {
        const nftBin = readFile(abiDir, 'Poap.bin')
        const nftContractFactory = new ethers.ContractFactory(nftAbi, nftBin, wallet)
        nftContract = await nftContractFactory.deploy()
        await nftContract.deployed()
        console.log('Deployed NFT at', nftContract.address)
    }

    // deploy Semaphore
    const semaphoreAbi = readFile(abiDir, 'Semaphore.abi')
    const semaphoreBin = readFile(abiDir, 'Semaphore.bin')
    const semaphoreContractFactory = new ethers.ContractFactory(semaphoreAbi, semaphoreBin, wallet)
    const semaphoreContract = await semaphoreContractFactory.deploy(15, 0, 0)
    await semaphoreContract.deployed()

    console.log('Deployed Semaphore at', semaphoreContract.address)

    // deploy OneOfUs
    const oouAbi = readFile(abiDir, 'OneOfUs.abi')
    const oouBin = readFile(abiDir, 'OneOfUs.bin')
    const oouContractFactory = new ethers.ContractFactory(oouAbi, oouBin, wallet)
    const oouContract = await oouContractFactory.deploy(
        nftContract.address,
        semaphoreContract.address,
        config.chain.poapEventId,
    )
    await oouContract.deployed()

    // set the owner of the Semaphore contract to the OneOfUs contract address
    const tx = await semaphoreContract.transferOwnership(oouContract.address)
    await tx.wait()
    console.log('Transferred ownership of the Semaphore contract')
    
	return {
		MiMC: mimcContract,
		Semaphore: semaphoreContract,
		NFT: nftContract,
        OneOfUs: oouContract,
	}
}

//function delay(milliseconds: number): Promise<void> {
    //return new Promise((resolve: Function) => setTimeout(resolve, milliseconds))
//}

if (require.main === module) {
    const parser = new ArgumentParser({
        description: 'Build and deploy contracts'
    })

    parser.addArgument(
        ['-s', '--solc'],
        {
            help: 'The path to the solc binary',
            required: false,
        }
    )

    parser.addArgument(
        ['-r', '--rpcUrl'],
        {
            help: 'The JSON-RPC URL of the Ethereum node',
            required: false,
        }
    )

    parser.addArgument(
        ['-o', '--out'],
        {
            help: 'The output directory for compiled files',
            required: true,
        }
    )

    parser.addArgument(
        ['-i', '--input'],
        {
            help: 'The input directory with .sol files',
            required: true,
        }
    )

    parser.addArgument(
        ['-k', '--privKey'],
        {
            help: 'The private key to use to deploy the contracts',
            required: false,
        }
    )

    parser.addArgument(
        ['-m', '--mainnet'],
        {
            help: 'Use the NFT contract address configured at config.chain.nftAddress',
            action: 'storeTrue',
        }
    )

    // parse command-line options
    const args = parser.parseArgs()

    const abiDir = path.resolve(args.out)
    const solDir = path.resolve(args.input)

    const deployKey = args.privKey ? args.privKey : config.chain.keys.deploy
    const solcBinaryPath = args.solc ? args.solc : 'solc'
    const rpcUrl = args.rpcUrl ? args.rpcUrl : config.chain.url
    const nftAddress = args.mainnet ? config.chain.nftAddress : null

    compileAndDeploy(abiDir, solDir, solcBinaryPath, rpcUrl, deployKey, nftAddress)
}

export {
    compileAndDeploy,
}
